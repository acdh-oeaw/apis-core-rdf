# Generated by Django 5.2.5 on 2025-08-20 14:30

from django.apps import apps
from django.db import migrations
from django.db.utils import DatabaseError


def rename_db_columns_using_appconfig(schema_editor, old_name, new_name):
    old_app, old_model = old_name.split(".")
    new_app, new_model = new_name.split(".")
    old_ptr_id = f"{old_model}_ptr_id"
    new_ptr_id = f"{new_model}_ptr_id"
    all_models = [
        model
        for appconfig in apps.get_app_configs()
        for model in appconfig.get_models()
    ]
    for model in all_models:
        with schema_editor.connection.cursor() as cursor:
            table = model._meta.db_table
            # get a list of columns for this models table
            try:
                columns = schema_editor.connection.introspection.get_table_description(
                    cursor, table
                )
            except DatabaseError:
                columns = []
            # and check if there is a column named after the old model
            if old_ptr_id in [column.name for column in columns]:
                # rename the column
                sql = f"ALTER TABLE {table} RENAME COLUMN {old_ptr_id} TO {new_ptr_id};"
                print(sql)
                cursor.execute(sql)
                # look if there are any constraints on this table
                # that are foreign keys and point to the old models table
                constraints = schema_editor.connection.introspection.get_constraints(
                    cursor, table
                )
                constraints = {
                    key: val
                    for key, val in constraints.items()
                    if val["foreign_key"] == (f"{old_app}_{old_model}", "id")
                }
                if constraints:
                    # sqlite does not support dropping and recreating constraints,
                    # so we have to 1) create a temporary table with the new constraint
                    # 2) copy the data from the orig table 3) drop the orig table
                    # 3) rename the temporary table
                    if schema_editor.connection.vendor == "sqlite":
                        res = cursor.execute(
                            f"SELECT sql FROM sqlite_schema WHERE NAME = '{table}'"
                        )
                        (statement,) = res.fetchone()
                        statement = statement.replace(table, table + "_tmp_copy")
                        statement = statement.replace(
                            f"{old_app}_{old_model}", f"{new_app}_{new_model}"
                        )
                        print(statement)
                        cursor.execute(statement)
                        copy_table = (
                            f"INSERT INTO {table}_tmp_copy SELECT * FROM {table}"
                        )
                        print(copy_table)
                        cursor.execute(copy_table)
                        statement = f"DROP TABLE {table}"
                        print(statement)
                        cursor.execute(statement)
                        statement = f"ALTER TABLE {table}_tmp_copy RENAME TO {table}"
                        print(statement)
                        cursor.execute(statement)
                    else:
                        for constraint in constraints:
                            statement = (
                                f"ALTER TABLE {table} DROP CONSTRAINT {constraint}"
                            )
                            print(statement)
                            cursor.execute(statement)
                            statement = f"ALTER TABLE {table} ADD CONSTRAINT {constraint} FOREIGN KEY ({new_ptr_id}) REFERENCES {new_app}_{new_model}(id) DEFERRABLE INITIALLY DEFERRED"
                            print(statement)
                            cursor.execute(statement)


def forward_func(apps, schema_editor):
    with schema_editor.connection.cursor() as cursor:
        copy_table = (
            "INSERT INTO entities_entity SELECT * FROM apis_metainfo_rootobject"
        )
        print(copy_table)
        cursor.execute(copy_table)
        print(
            f"Copied {cursor.rowcount} rows from apis_metainfo_rootobject to entities_entity"
        )
    rename_db_columns_using_appconfig(
        schema_editor, "apis_metainfo.rootobject", "entities.entity"
    )


def reverse_func(apps, schema_editor):
    rename_db_columns_using_appconfig(
        schema_editor, "entities.entity", "apis_metainfo.rootobject"
    )
    with schema_editor.connection.cursor() as cursor:
        remove_rootobjects = "DELETE FROM entities_entity WHERE ID IN (SELECT ID FROM apis_metainfo_rootobject)"
        print(remove_rootobjects)
        cursor.execute(remove_rootobjects)
        print(
            f"Deleted {cursor.rowcount} rows from entities_entity that are also present in apis_metainfo_rootobject"
        )


class Migration(migrations.Migration):
    dependencies = [
        ("entities", "0001_initial"),
    ]

    operations = [migrations.RunPython(forward_func, reverse_func)]
