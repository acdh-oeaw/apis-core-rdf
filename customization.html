

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Customization &mdash; APIS 0.38.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=9fa2033d"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Additional Features" href="features.html" />
    <link rel="prev" title="Configuration" href="configuration.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            APIS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ontology.html">Create your <span class="xref std std-term">ontology</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Customization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#list-views">List views</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#list-view-templates">List view templates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#create-and-update-views">Create and Update views</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#create-and-update-view-templates">Create and update view templates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#autocomplete-views">Autocomplete views</a></li>
<li class="toctree-l2"><a class="reference internal" href="#import-view">Import view</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#import-view-template">Import view template</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#class-method-and-template-lookup">Class, method and template lookup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#importing-data-from-external-resources">Importing data from external resources</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Additional Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://acdh-oeaw.github.io/apis-core-rdf/htmlcov/">Coverage</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">APIS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Customization</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/customization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="customization">
<h1>Customization<a class="headerlink" href="#customization" title="Link to this heading"></a></h1>
<p>APIS is designed to be easily customizable. This section describes how you can
customize the views and the templates of the views that are shipped with
APIS by injecting classes and methods that are then automatically used by the generic views.
The core of the logic described here is based on the <a class="reference internal" href="modules/apis_core.generic.html#module-apis_core.generic" title="apis_core.generic"><code class="xref py py-mod docutils literal notranslate"><span class="pre">apis_core.generic</span></code></a>.
It provides generic CRUD views and API views for all models that are configured
to use it. To make a model use the generic functionality, it has to inherit from
<a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.abc.GenericModel" title="apis_core.generic.abc.GenericModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.abc.GenericModel</span></code></a>.
In standard APIS those models are</p>
<ul class="simple">
<li><p><a class="reference internal" href="modules/apis_core.apis_metainfo.html#apis_core.apis_metainfo.models.RootObject" title="apis_core.apis_metainfo.models.RootObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.apis_metainfo.models.RootObject</span></code></a></p></li>
<li><p><a class="reference internal" href="modules/apis_core.apis_metainfo.html#apis_core.apis_metainfo.models.Uri" title="apis_core.apis_metainfo.models.Uri"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.apis_metainfo.models.Uri</span></code></a></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.apis_relations.models.Triple</span></code></p></li>
<li><p><a class="reference internal" href="modules/apis_core.collections.html#apis_core.collections.models.SkosCollection" title="apis_core.collections.models.SkosCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.collections.models.SkosCollection</span></code></a></p></li>
<li><p><a class="reference internal" href="modules/apis_core.collections.html#apis_core.collections.models.SkosCollectionContentObject" title="apis_core.collections.models.SkosCollectionContentObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.collections.models.SkosCollectionContentObject</span></code></a></p></li>
</ul>
<p>The <a class="reference internal" href="modules/apis_core.history.html#module-apis_core.history" title="apis_core.history"><code class="xref py py-mod docutils literal notranslate"><span class="pre">apis_core.history</span></code></a> module also uses the generic views for
its models. This means that you can use the generic views for the historical
models of your own ontology. E.g. if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your
<code class="docutils literal notranslate"><span class="pre">your_app.models</span></code> module, you can use the generic views for it.
<code class="docutils literal notranslate"><span class="pre">/apis/your_app.historicalperson/</span></code>
will be the URL for the list view of the historical model.
<code class="docutils literal notranslate"><span class="pre">/apis/api/your_app.historicalperson/</span></code> for the API view.</p>
<p>If you want to use the generic app for your own model, simple make your model
inherit from <a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.abc.GenericModel" title="apis_core.generic.abc.GenericModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.abc.GenericModel</span></code></a>.</p>
<section id="list-views">
<h2>List views<a class="headerlink" href="#list-views" title="Link to this heading"></a></h2>
<p>The list views consist of a <a class="reference external" href="https://django-filter.readthedocs.io">django-filters</a> <a class="reference external" href="https://django-filter.readthedocs.io/en/stable/ref/filterset.html">filterset</a> on the
left and a <a class="reference external" href="django-tables2.readthedocs.io/">django-tables</a> <a class="reference external" href="https://django-tables2.readthedocs.io/en/latest/pages/api-reference.html#table">table</a>
of results on the right side.</p>
<p>The default filterset used is
<a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.filtersets.GenericFilterSet" title="apis_core.generic.filtersets.GenericFilterSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.filtersets.GenericFilterSet</span></code></a>. You can override the
filterset for you models by defining a custom filterset class in
<code class="docutils literal notranslate"><span class="pre">your_app.filtersets</span></code>. The filterset has to be named <code class="docutils literal notranslate"><span class="pre">&lt;Modelname&gt;FilterSet</span></code>,
so if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your app <code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for
the filterset <code class="docutils literal notranslate"><span class="pre">myproject.filtersets.PersonFilterSet</span></code>. You can inherit from
<a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.filtersets.GenericFilterSet" title="apis_core.generic.filtersets.GenericFilterSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.filtersets.GenericFilterSet</span></code></a> and add your
customzations.</p>
<p>The default table used is <a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.tables.GenericTable" title="apis_core.generic.tables.GenericTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.tables.GenericTable</span></code></a>. You
can override the table for your models by defining a custom table class in
<code class="docutils literal notranslate"><span class="pre">your_app.tables</span></code>. The table class has to be named <code class="docutils literal notranslate"><span class="pre">&lt;Modelname&gt;Table</span></code>, so
if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your app <code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for
the table class <code class="docutils literal notranslate"><span class="pre">myproject.tables.PersonTable</span></code>. You can inherit from
<a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.tables.GenericTable" title="apis_core.generic.tables.GenericTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.tables.GenericTable</span></code></a> and add your customizations.
<a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.tables.GenericTable" title="apis_core.generic.tables.GenericTable"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.tables.GenericTable</span></code></a> also contains a handful of
useful <a class="reference external" href="https://django-tables2.readthedocs.io/en/latest/pages/api-reference.html#columns">django table columns</a>
that you might want to use.</p>
<p>Your table can also contain a <code class="docutils literal notranslate"><span class="pre">paginate_by</span></code> attribute, which is then used
by the list view to determines the number of items per page. When this is not
set, the page size defaults to <code class="docutils literal notranslate"><span class="pre">25</span></code>. To disable pagination altogether, use
<code class="docutils literal notranslate"><span class="pre">table_pagination</span> <span class="pre">=</span> <span class="pre">False</span></code>.</p>
<p>The base queryset that is used in the listview, which is then filtered using
the django-filters filter, is <code class="docutils literal notranslate"><span class="pre">model.objects.all()</span></code> - but you can override
the queryset by creating a custom queryset for your model in
<code class="docutils literal notranslate"><span class="pre">your_app.querysets</span></code>. The queryset function has to be named
<code class="docutils literal notranslate"><span class="pre">&lt;Modelname&gt;ListViewQueryset</span></code>, so if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your app
<code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for the queryset
<code class="docutils literal notranslate"><span class="pre">myproject.querysets.PersonListViewQueryset</span></code>.</p>
<section id="list-view-templates">
<h3>List view templates<a class="headerlink" href="#list-view-templates" title="Link to this heading"></a></h3>
<p>The list view looks for templates using the <code class="docutils literal notranslate"><span class="pre">_list.html</span></code> suffix. It uses the
<code class="docutils literal notranslate"><span class="pre">generic/generic_list.html</span></code> template as fallback, but you can use a custom
template using your model name, so if your model is <code class="docutils literal notranslate"><span class="pre">myproject.Person</span></code> then
you can use the <code class="docutils literal notranslate"><span class="pre">myproject/person_list.html</span></code> template to override the generic
template.</p>
</section>
</section>
<section id="create-and-update-views">
<h2>Create and Update views<a class="headerlink" href="#create-and-update-views" title="Link to this heading"></a></h2>
<p>The create and update view use the form
<a class="reference internal" href="modules/apis_core.generic.forms.html#apis_core.generic.forms.GenericModelForm" title="apis_core.generic.forms.GenericModelForm"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.forms.GenericModelForm</span></code></a> by default. You can override
the form it uses by creating a custom form in <code class="docutils literal notranslate"><span class="pre">your_app.forms</span></code>. The form class
has to be named <code class="docutils literal notranslate"><span class="pre">&lt;Modelname&gt;Form</span></code>, so if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your
app <code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for the form class
<code class="docutils literal notranslate"><span class="pre">myproject.forms.PersonForm</span></code>.</p>
<section id="create-and-update-view-templates">
<h3>Create and update view templates<a class="headerlink" href="#create-and-update-view-templates" title="Link to this heading"></a></h3>
<p>The create and update views looks for templates using the <code class="docutils literal notranslate"><span class="pre">_form.html</span></code>
suffix. It uses the <code class="docutils literal notranslate"><span class="pre">generic/generic_form.html</span></code> template as fallback, but you
can use a custom template using your model name, so if your model is
<code class="docutils literal notranslate"><span class="pre">myproject.Person</span></code> then you can use the <code class="docutils literal notranslate"><span class="pre">myproject/person_form.html</span></code>
template to override the generic template.</p>
</section>
</section>
<section id="autocomplete-views">
<h2>Autocomplete views<a class="headerlink" href="#autocomplete-views" title="Link to this heading"></a></h2>
<p>The autocomplete views filter your model instances based on a query string
provided. By default, the autocomplete views use
<a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.helpers.generate_search_filter" title="apis_core.generic.helpers.generate_search_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">apis_core.generic.helpers.generate_search_filter()</span></code></a> to filter the model
queryset. You can override the queryset by creating a custom queryset for your
model in <code class="docutils literal notranslate"><span class="pre">your_app.querysets</span></code>. The queryset function has to be named
<code class="docutils literal notranslate"><span class="pre">&lt;Modelname&gt;AutocompleteQueryset</span></code>, so if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your
app <code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for the queryset
<code class="docutils literal notranslate"><span class="pre">myproject.querysets.PersonAutocompleteQueryset</span></code>.</p>
<p>The results of the autocomplete view can be themed using templates. The
autocomplete view looks for templates using the <code class="docutils literal notranslate"><span class="pre">autocomplete_result.html</span></code>
suffix, if no such template is found, the string representation of the result
is used. The autocomplete view uses the same template search function as for
other templates, so if you have a model <code class="docutils literal notranslate"><span class="pre">myproject.Person</span></code> then you can use
the <code class="docutils literal notranslate"><span class="pre">myproject/person_autocomplete_result.html</span></code> template.</p>
<p>The results of the autocomplete view can be extended with additional results
coming from another source (an external API or another queryset). The view
looks for this function in <code class="docutils literal notranslate"><span class="pre">your_app.querysets</span></code> and it has to be named
<code class="docutils literal notranslate"><span class="pre">&lt;Modelname&gt;ExternalAutocomplete</span></code>, so if you have a model <code class="docutils literal notranslate"><span class="pre">Person</span></code> in your
app <code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for the function in
<code class="docutils literal notranslate"><span class="pre">myproject.querysets.PersonExternalAutocomplete</span></code>.</p>
<p>Lets say you have an app called <code class="docutils literal notranslate"><span class="pre">myapp</span></code> with a
<code class="docutils literal notranslate"><span class="pre">models.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
     <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
</pre></div>
</div>
<p>then the respective autocomplete class should reside in <code class="docutils literal notranslate"><span class="pre">myapp.querysets</span></code> and
has to be called <code class="docutils literal notranslate"><span class="pre">PersonExternalAutocomplete</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PersonExternalAutocomplete</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">extract_results</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">the</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;https://some.uri.tld/search?q=</span><span class="si">{</span><span class="n">q</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">extract_results</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">return</span> <span class="p">{}</span>
</pre></div>
</div>
<p>The class has to have a <code class="docutils literal notranslate"><span class="pre">get_results</span></code> method that receives a query as the first
parameter and returns a result in the format, the <a class="reference external" href="https://django-autocomplete-light.readthedocs.io/">django-autocomplete-light</a>
module uses- this is a dict with the keys “id”, “text” and “selected_text”.</p>
</section>
<section id="import-view">
<h2>Import view<a class="headerlink" href="#import-view" title="Link to this heading"></a></h2>
<p>The import view uses the form
<a class="reference internal" href="modules/apis_core.generic.forms.html#apis_core.generic.forms.GenericImportForm" title="apis_core.generic.forms.GenericImportForm"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.forms.GenericImportForm</span></code></a> by default. You can override
the form it uses by creating a custom form in <code class="docutils literal notranslate"><span class="pre">your_app.forms</span></code>. The form
class has to be named <code class="docutils literal notranslate"><span class="pre">&lt;ModelName&gt;ImportForm</span></code>, so if you have a model
<code class="docutils literal notranslate"><span class="pre">Person</span></code> in your app <code class="docutils literal notranslate"><span class="pre">myproject</span></code>, the view looks for the form class
<code class="docutils literal notranslate"><span class="pre">myproject.forms.PersonImportForm</span></code>.</p>
<section id="import-view-template">
<h3>Import view template<a class="headerlink" href="#import-view-template" title="Link to this heading"></a></h3>
<p>The import view looks for templates using the <code class="docutils literal notranslate"><span class="pre">_import.html</span></code> suffix. It uses
the <code class="docutils literal notranslate"><span class="pre">generic/generic_import.html</span></code> template as fallback, but you can use a
custom template using your model name, so if your model is <code class="docutils literal notranslate"><span class="pre">myproject.Person</span></code>
then you can use the <code class="docutils literal notranslate"><span class="pre">myproject/person_import.html</span></code> template to override the
generic template.</p>
</section>
</section>
<section id="class-method-and-template-lookup">
<h2>Class, method and template lookup<a class="headerlink" href="#class-method-and-template-lookup" title="Link to this heading"></a></h2>
<p>As mentioned above, APIS tries to find the correct class or method to override
the ones the <code class="docutils literal notranslate"><span class="pre">generic</span></code> one ships. This is done using
<code class="xref py py-func docutils literal notranslate"><span class="pre">apis_core.generic.helpers.first_match_via_mro()</span></code>. The method does not only
look for possible overrides using the name of the model itself, but also using
all the parent models following the full inheritance chain. So if all your models
inherit from <code class="docutils literal notranslate"><span class="pre">MyAbstractModel</span></code>, you can for example create an override table
for all your models by creating a <code class="docutils literal notranslate"><span class="pre">myproject.tables.MyAbstractModelTable</span></code>.</p>
</section>
<section id="importing-data-from-external-resources">
<h2>Importing data from external resources<a class="headerlink" href="#importing-data-from-external-resources" title="Link to this heading"></a></h2>
<p>APIS provides the structure for easily importing data from external resources.
One main component for this are <code class="docutils literal notranslate"><span class="pre">Importer</span></code> classes. They always belong to a
Django model, reside in the same app as the Django model in the <code class="docutils literal notranslate"><span class="pre">importers</span></code>
module and are named after the Django model. So if you have an app called
<code class="docutils literal notranslate"><span class="pre">myapp</span></code> with a <code class="docutils literal notranslate"><span class="pre">models.py</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
     <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
</pre></div>
</div>
<p>then the respective importer should reside in <code class="docutils literal notranslate"><span class="pre">myapp.importers</span></code> and has to be
called <code class="docutils literal notranslate"><span class="pre">PersonImporter</span></code>.</p>
<p>An importer takes two arguments to instantiate: an <code class="docutils literal notranslate"><span class="pre">uri</span></code> and a <code class="docutils literal notranslate"><span class="pre">model</span></code>. The
importers task is then to create a model instance from this URI, usually by
fetching data from the URI, parsing it and extracting the needed fields.
The instance should then be returned by the <code class="docutils literal notranslate"><span class="pre">create_instance</span></code> method of the
importer. There is <a class="reference internal" href="modules/apis_core.generic.html#apis_core.generic.importers.GenericModelImporter" title="apis_core.generic.importers.GenericModelImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.importers.GenericModelImporter</span></code></a>
which you can inherit from. It is used by default of no other importer is defined for the model and it tries to do the right thing out of the box: it first looks if there is an RDF configuration for the URI and if that fails tries to parse the URI response as json.</p>
<p>To use this logic in forms, there is
<a class="reference internal" href="modules/apis_core.generic.forms.html#apis_core.generic.forms.fields.ModelImportChoiceField" title="apis_core.generic.forms.fields.ModelImportChoiceField"><code class="xref py py-class docutils literal notranslate"><span class="pre">apis_core.generic.forms.fields.ModelImportChoiceField</span></code></a> which is
based on <a class="reference external" href="https://docs.djangoproject.com/en/stable/ref/forms/fields/#modelchoicefield">django.forms.ModelChoiceField</a>. It checks if the passed value starts
with <code class="docutils literal notranslate"><span class="pre">http</span></code> and if so, it uses the importer that fits the model and uses it to
create the model instance.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="configuration.html" class="btn btn-neutral float-left" title="Configuration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="features.html" class="btn btn-neutral float-right" title="Additional Features" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2025, Matthias Schlögl, Birger Schacht, K Kollmann, Saranya Balasubramanian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>